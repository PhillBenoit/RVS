:toc:
:numbered:
:data-uri:

<<junk,echo=FALSE>>=    Somehow, this avoids the "figure margins too large" error ~kbroman
par(mar=rep(0,4))
@

<<options, echo=FALSE, eval = TRUE, echo = FALSE>>=
  options(width=75, continue = " ")
  library("Bureau")
@ 
== RVSharing Examples ==

Let's look at some simple pedigree structures.

=== Siblings ===

<<RVsharing.toy2, eval = TRUE, echo = TRUE>>=
id <- paste0("sub", 1:4)
fa.id <- c(NA,NA,"sub1","sub1")
ma.id <- c(NA,NA,"sub2","sub2")

test.ped <- pedigree(id = id, dadid = fa.id, momid = ma.id, sex = c(1,2,1,2))

fa.id <- ifelse(is.na(fa.id),"0",fa.id)
ma.id <- ifelse(is.na(ma.id),"0",ma.id)

@ 
<<showped>>=
test.ped
@ 
<<plotped, fig = TRUE, width = 3, eval = TRUE, echo = TRUE>>=
plot(test.ped)
@ 
<<kinship, echo = FALSE, eval = FALSE>>=
2*kinship(test.ped)
@ 
Apply the RVsharing method using a pedigree object. ("rare_variant_sharing_v3.R")
<<test>>=
RVsharing(test.ped)
@ 
Now use three ID vectors.
<<test2>>=
RVsharing(id = id, dad.id = fa.id, mom.id = ma.id )
@ 
=== First Cousins ===
<<RVsharing.toy2, eval = TRUE, echo = FALSE>>=
id <- paste0("sub", 1:8)
fa.id <- c(NA,NA,NA,"sub1","sub1", NA,"sub3","sub5")
ma.id <- c(NA,NA,NA,"sub2","sub2", NA,"sub4","sub6")
test.ped <- pedigree(id = id, dadid = fa.id, momid = ma.id, sex = c(1,2,1,2,1,2,2,2))
fa.id <- ifelse(is.na(fa.id),"0",fa.id)
ma.id <- ifelse(is.na(ma.id),"0",ma.id)

@ 
<<showped2, echo = FALSE, results = hide>>=
test.ped.first.cousins <- test.ped
test.ped
@ 

<<plotped2, fig = TRUE, width = 3, eval = TRUE, echo = FALSE>>=
plot(test.ped)
@ 

<<kinship2, echo = FALSE, eval = FALSE>>=
2*kinship(test.ped)
@ 
<<test3>>=
RVsharing(id = id, dad.id = fa.id, mom.id = ma.id )
@
<<test4, eval = TRUE, echo = TRUE>>=
RVsharing(test.ped)
@ 
Direct application of function in "rare_variant_sharing_v3.R".
<<RVsharing-fn, echo = TRUE, eval = TRUE>>=
Bureau:::RVsharing.fn(id = id, dad.id = fa.id, mom.id = ma.id )
@
// === RVsharing.fn ===
// This is the function used above and in the RVsharing method.
// ----
// # By Alexandre Bureau
// # Version 0.1
// # 2013/02/08

// RVsharing.fn = function(id, dad.id, mom.id)
// {

// N = length(id)
// # Indicator vector of final descendants
// fdi = which(!(id%in%dad.id | id%in%mom.id))
// nfd = length(fdi)
// if (nfd < 2) stop("There are fewer than 2 descendants for which to compute a rare variant sharing probability.")

// # Getting the depth of each subject in the pedigree
// dv = kindepth(id, dad.id, mom.id)
// md = max(dv)
// # Number of founders
// Nf = sum(dv==0)

// # Collecting the degrees between the sequenced children, the founders and the intermediate ancestors
// degvec = currentnonfounders = currentfounders = numeric(nfd)
// active = rep(TRUE,nfd) 
// # List of distance to founders of each final descendant
// desfounders = list()
// # List of list of final descendants and intermediate ancestors below each founder below each ancestor
// foundersdegreedes = list()
// # List of indicators of whether each descendant of a founder is an intermediate ancestor
// iancestor.as.descendant = list()
// # List of intermediate ancestors
// iancestors = numeric(0)
// # List of vectors of degrees of relatedness of final descendants below each intermediate ancestor
// ancestorsdegreedes = list()
// ia = 1

// # Initializing the currentnonfounders vector with the final descendants at the deepest level
// currentnonfounders[dv[fdi]==md] = id[dv==md]

// # Loop from highest to lowest depth
// if (md > 1)
// {
// for (lev in (md-1):1)
//   {
//   # Incrementing D for final descendants and intermediate ancestors
//   degvec[dv[fdi]>lev&active] = degvec[dv[fdi]>lev&active] + 1
//   # Listing ancestors at current depth of final descendants and intermediate ancestors
//   # Loop over final descendants and intermediate ancestors with depth greater than current depth
//   for (i in (1:nfd)[dv[fdi]>lev&active])
//     {
//     # The currentnonfounders are those from the previous level
//     currentdad=dad.id[id == currentnonfounders[i]]
//     currentmom=mom.id[id == currentnonfounders[i]]  
//     # Identify non-founder among mom and dad
//     currentnonfounders[i] = ifelse(dad.id[id == currentdad]==0,currentmom,currentdad)
//     # Identify founder among mom and dad
//     currentfounders[i] = ifelse(dad.id[id == currentdad]==0,currentdad,currentmom)
//     }
//   # Adding final descendent at the current level to the currentnonfounders for the next level
//   currentnonfounders[dv[fdi]==lev] = id[fdi][dv[fdi]==lev]

//   # Checking if there is an intermediate ancestor with more than one descendant at the current level
//   tab.currentnonfounders = table(currentnonfounders[currentnonfounders>0&active])
//   # If there is more than one, stop because it is not implemented
//   if (sum(tab.currentnonfounders>1) > 1) stop ("More than one intermediate ancestor at the same level with two or more descendant")
//   # If there is any, there is only one
//   if (any(tab.currentnonfounders>1))
//     {
//     iancestors[ia] = as.numeric(names(tab.currentnonfounders)[tab.currentnonfounders>1])
//     # Adding the degrees of final descendants below the current intermediate ancestor to his list
//     ancestorsdegreedes[[ia]] = degvec[currentnonfounders==iancestors[ia]&active]
//     # Include degrees between spouse and final descendants in list of ancestors  (assumes only one spouse)
//     foundersdegreedes[[ia]] = list(degvec[currentnonfounders==iancestors[ia]&active])
//     # Setting indicator of whether the descendant is the previous intermediate ancestor
//     if (ia>1)
//       iancestor.as.descendant[[ia]] = list(id[fdi][currentnonfounders==iancestors[ia]&active] == iancestors[ia-1])
//     else iancestor.as.descendant[[ia]] = list(rep(FALSE,length(foundersdegreedes[[ia]][[1]])))
//     # Include previous ancestors of final descendants if any
//     if (any(as.numeric(names(desfounders)) %in% id[fdi][currentnonfounders==iancestors[ia]&active]))
//       {
//       ii = 1
//       tmp = desfounders[as.numeric(names(desfounders)) %in% id[fdi][currentnonfounders==iancestors[ia]&active]]
//       # Loop over final descendants 
//       for (k in 1:length(tmp))
//         {
//         foundersdegreedes[[ia]][(ii+1):(ii+length(tmp[[k]]))] = tmp[[k]]
//         # Setting indicator of whether the descendant of all ancestors in tmp[[k]] is the previous intermediate ancestor
//         iancestor.as.descendant[[ia]][(ii+1):(ii+length(tmp[[k]]))] = list(ifelse (ia>1, as.numeric(names(tmp)[k]) == iancestors[ia-1], FALSE))
//         ii = ii + length(tmp[[k]])
//         # Adding spouse of intermediate ancestor to list of founders of current final descendant
        
//         }
//       }
//     }
//   # Adding the current founder ancestral to each final descendants to his list of founders
//   if (length(currentfounders[currentfounders>0][!is.na(currentfounders)])>0)
//     {
//     for (i in (1:nfd)[dv[fdi]>lev&active])
//       {
//       # If there are at least i elements in desfounders
//       if (length(desfounders)>=i)
//         {
//         desfounders[[i]][length(desfounders[[i]])+1] = degvec[i]
//         # Keeping the name of the founder
//         names(desfounders[[i]])[length(desfounders[[i]])] = currentfounders[i]
//         }
//       else 
//         {
//         desfounders[[i]] = list(degvec[i])
//         names(desfounders[[i]])[1] = currentfounders[i]
//         }
//       # Assigning the ID of the subject as name
//       names(desfounders)[i] = id[fdi][i]
//       }
//     }
//   # Finishing processing the current intermediate ancestor if there is one
//   if (any(tab.currentnonfounders>1))
//     {
//     # Turning these final descendants to inactive
//     active[currentnonfounders==iancestors[ia]] = FALSE
//     # Removing spouse(s) of intermediate ancestor from currentfounders 
//     # Note: the spouse(s) have the same positions in the currentfounders vector as the 
//     # intermediate ancestor in the currentnonfounders vector
//     currentfounders = currentfounders[currentnonfounders != iancestors[ia]]
//     # Adding the intermediate ancestor to the vector of subjects with a degree
//     nfd = nfd + 1
//     fdi[nfd] = which(id==iancestors[ia])
//     degvec[nfd] = 0
//     active[nfd] = TRUE
//     # Adding the intermediate ancestor to the vector of currentnonfounders
//     currentnonfounders[nfd] = iancestors[ia]
//     # Incrementing ia
//     ia = ia + 1
//     }
//   }
// }
// # Depth 0: there should be at most 2 founders common to all subjects
// # We assign one of them as a dummy "intermediate" ancestor
// # Incrementing D for final descendants and intermediate ancestors
// degvec[active] = degvec[active] + 1
// # Listing ancestors at current depth of final descendants and intermediate ancestors
// # The currentnonfounders are those from the previous level
// currentdads=dad.id[id %in% currentnonfounders[active]]
// currentmoms=mom.id[id %in% currentnonfounders[active]]  
    
// # If all subjects have the same dad, use him as last ancestor
// if (all(currentdads==currentdads[1]))
//   { 
//   iancestors[ia] = currentdads[1]
//   currentfounders = currentmoms
//   }
// # else if all subjects have the same mom, use her as last ancestor
// else
//   {
//   if (all(currentmoms==currentmoms[1])) 
//     {
//     iancestors[ia] = currentmoms[1]
//     currentfounders = currentdads
//     }  
// # else there is no common ancestor, and the probability of sharing is 0
//   else return (0)
//   }
     
//     # Adding the degrees of final descendants below the current intermediate ancestor to his list
//     ancestorsdegreedes[[ia]] = degvec[active]
//     # Include first spouse in list of ancestors
//     spousevec = unique(currentfounders)
//     foundersdegreedes[[ia]]= list(degvec[currentfounders==spousevec[1]&active])
//     # Setting indicator of whether the descendant is the previous intermediate ancestor
//     if (ia>1)
//       iancestor.as.descendant[[ia]] = list(id[fdi][currentfounders==spousevec[1]&active] == iancestors[ia-1])
//     else iancestor.as.descendant[[ia]] = list(rep(FALSE,length(foundersdegreedes[[ia]][[1]])))
//     # Add additional spouses if any
//     if(length(spousevec)>1)
//       {
//       for (i in 2:length(spousevec))
//         {
//         foundersdegreedes[[ia]][[i]] = degvec[currentfounders==spousevec[i]&active]
//         if (ia>1)
//           iancestor.as.descendant[[ia]][[i]] = id[fdi][currentfounders==spousevec[i]&active] == iancestors[ia-1]
//         else iancestor.as.descendant[[ia]][[i]] = rep(FALSE,length(foundersdegreedes[[ia]][[i]]))
//         }
//       }  
//     # Include previous ancestors of final descendants if any
//     if (any(as.numeric(names(desfounders)) %in% id[fdi][active]))
//       {
//       ii = length(spousevec)
//       tmp = desfounders[as.numeric(names(desfounders)) %in% id[fdi][active]]
//       # Loop over final descendants 
//       for (k in 1:length(tmp))
//         {
//         foundersdegreedes[[ia]][(ii+1):(ii+length(tmp[[k]]))] = tmp[[k]]
//         # Setting indicator of whether the descendant of all ancestors in tmp[[k]] is the previous intermediate ancestor
//         iancestor.as.descendant[[ia]][(ii+1):(ii+length(tmp[[k]]))] = list(ifelse (ia>1, as.numeric(names(tmp)[k]) == iancestors[ia-1], FALSE))
//         ii = ii + length(tmp[[k]])
//         }
//       }
//       # Adding the current founder couple ancestral to each final descendants to his list of founders
//       # This is not required for the sharing probability computation, but is used for kinship estimation
//     # print(currentfounders)
//     for (i in (1:nfd)[active])
//       {
//       j = 1
//       # If there are at least i elements in desfounders
//       if (length(desfounders)>=i)
//         {
//         desfounders[[i]][length(desfounders[[i]])+(1:2)] = degvec[i]
//         # Keeping the name of the founder
//         names(desfounders[[i]])[length(desfounders[[i]])-1] = currentfounders[j]
//         names(desfounders[[i]])[length(desfounders[[i]])] = iancestors[ia]
//         }
//       else 
//         {
//         desfounders[[i]] = rep(degvec[i],2)
//         names(desfounders[[i]])[1] = currentfounders[j]
//         names(desfounders[[i]])[2] = iancestors[ia]
//         }
//       # Assigning the ID of the subject as name
//       names(desfounders)[i] = id[fdi][i]
//       j = j+1
//       }

// # Computation of numerator
// num = 1
// for (i in 1:ia)
//   num = num * 1/2^sum(ancestorsdegreedes[[i]])
// # Computation for top founder or founders
// # If there is only one spouse, then a couple of founders can transmit a variant to all final descendents
// if (length(spousevec)==1) num = num*2
// # Division by the number of founders
// num = num/Nf
 
// # Computation of denominator
// # Probability that no variant has been transmitted
// p0 = 0
// # Probability that no variant has been transmitted from previous intermediate ancestor
// pk = 1
// for (i in 1:ia)
//   {
//   for (j in 1:length(foundersdegreedes[[i]]))
//     p0 = p0 + prod((1-1/2^foundersdegreedes[[i]][[j]]) + ifelse(iancestor.as.descendant[[i]][[j]],(1/2^foundersdegreedes[[i]][[j]])*pk,0))
//   # Updating the probability for the previous intermediate ancestor, who becomes the current intermediate ancestor
//   # For now, intermediate ancestors can have only one spouse, this is why we take the indicators of the first founder attached to him
//   if (i<ia) pk = prod((1-1/2^ancestorsdegreedes[[i]]) + ifelse(iancestor.as.descendant[[i]][[1]],1/2^ancestorsdegreedes[[i]]*pk,0))
//   }
// # At the end, add the probability from the dummy "intermediate" ancestor. He is currently the only one who can have more than one spouse
// # Since only one of his spouses can be the parent of the previous intermediate ancestor, sapply returns only one non-zero term.
// # The summation returns in fact the value of that single non-zero term
// p0 = p0 + prod((1-1/2^ancestorsdegreedes[[i]]) + sum(sapply(iancestor.as.descendant[[i]][1:length(spousevec)],function(lv,deg,pk) ifelse(lv, (1/2^deg) * pk,0), deg=ancestorsdegreedes[[i]],pk=pk)))
// # Sharing probability
// pshare = num/(1-p0/Nf)
// list(pshare=pshare,iancestors=iancestors,desfounders=desfounders,id=id,dad.id=dad.id,mom.id=mom.id)
// }

// # Wrappers for pedigree object
// # Returns only pshare
// RVsharing.ped.pshare = function(ped)
// {
// id = ped$id
// dad.id = mom.id = numeric(length(id))
// dad.id[ped$findex>0] = ped$id[ped$findex]
// mom.id[ped$mindex>0] = ped$id[ped$mindex]
// RVsharing(id,dad.id,mom.id)$pshare
// } 

// # Returns object
// RVsharing.ped = function(ped)
// {
// id = ped$id
// dad.id = mom.id = numeric(length(id))
// dad.id[ped$findex>0] = ped$id[ped$findex]
// mom.id[ped$mindex>0] = ped$id[ped$mindex]
// RVsharing(id,dad.id,mom.id)
// } 

// ----
=== Second Cousins ===
<<RVsharing.toy3, eval = TRUE, echo = FALSE>>=
id <- paste0("sub", 1:12)
fa.id <- c(NA,NA,NA,"sub1","sub1", NA,"sub3","sub5",NA,NA,"sub9","sub10")
ma.id <- c(NA,NA,NA,"sub2","sub2", NA,"sub4","sub6",NA,NA,"sub7","sub8")
test.ped <- pedigree(id = id, dadid = fa.id, momid = ma.id, sex = c(1,2,1,2,1,2,2,2,1,1,2,2))
#fa.id <- ifelse(is.na(fa.id),"0",fa.id)
#ma.id <- ifelse(is.na(ma.id),"0",ma.id)
@ 
<<showped3, echo = FALSE, results = hide>>=
test.ped.second.cousins <- test.ped
test.ped
@ 

<<plotped3, fig = TRUE, width = 3, eval = TRUE, echo = FALSE>>=
plot(test.ped)
@ 

<<test5, echo = TRUE, eval = TRUE>>=
RVsharing(id = id, dad.id = fa.id, mom.id = ma.id )
RVsharing(ped = test.ped )
@
// == Numerical ID vectors ==
// <<RVsharing.toynum, eval = TRUE, echo = TRUE>>=
// id <- as.numeric(1:4)
// fa.id <- as.numeric(c(NA,NA,1,1))
// ma.id <- as.numeric(c(NA,NA,2,2))

// test.ped <- pedigree(id = id, dadid = fa.id, momid = ma.id, sex = c(1,2,1,2))

// fa.id <- ifelse(is.na(fa.id),0,fa.id)
// ma.id <- ifelse(is.na(ma.id),0,ma.id)

// @ 
// Apply the RVsharing method using a pedigree object. ("rare_variant_sharing_v3.R")
// <<test>>=
// RVsharing(test.ped)
// @ 
// Now use three numerical ID vectors.
// <<test2>>=
// class(id)
// class(fa.id)
// class(ma.id)
// RVsharing(id = id, dad.id = fa.id, mom.id = ma.id )
// @ 
== Gene Dropping ==
=== First Cousins ===
<<testpedfirst, width = 3, fig = TRUE>>=
plot(test.ped.first.cousins)
@
<<firstcousins, cache = FALSE>>=
trio3 <- new("Trio", id = "sub5", spouse = "sub6", offspring = list("sub8") )
trio2 <- new("Trio", id = "sub4", spouse = "sub3", offspring = list("sub7") )
trio1 <- new("Trio", id = "sub1", spouse = "sub2", offspring = list(trio2, trio3) )
geno.vec <- c(1,0,0,NA,NA,0,NA,NA)
names(geno.vec) <- paste0("sub",1:8)
share.vec <- c()
occur.vec <- c()
i <- 1; n.occur <- 1e4; n.bail <- 10*n.occur
while( sum(occur.vec) < n.occur & i <= n.bail ){
      founder <- sample(c(1,2,3,6),1,replace = FALSE)
      geno.vec[founder] <- 1
      geno.vec.sim <- GeneDrop(trio1, geno.vec)
      share.vec <- c(share.vec, geno.vec.sim["sub7"]==1 & geno.vec.sim["sub8"]==1)
      occur.vec <- c(occur.vec, geno.vec.sim["sub7"]==1 | geno.vec.sim["sub8"]==1)
      geno.vec[founder] <- 0
      i <- i + 1
}
i
sum(share.vec)
sum(occur.vec)
(p <- sum(share.vec)/sum(occur.vec))
1/p
@

=== Second Cousins ===
<<testpedsecond, width = 3, fig = TRUE>>=
plot(test.ped.second.cousins)
@
<<secondcousins, eval = TRUE, echo = TRUE, cache = FALSE>>=
trio5 <- new("Trio", id = "sub8", spouse = "sub10", offspring = list("sub12") )
trio4 <- new("Trio", id = "sub7", spouse = "sub9", offspring = list("sub11") )
trio3 <- new("Trio", id = "sub5", spouse = "sub6", offspring = list(trio5) )
trio2 <- new("Trio", id = "sub4", spouse = "sub3", offspring = list(trio4) )
trio1 <- new("Trio", id = "sub1", spouse = "sub2", offspring = list(trio2, trio3) )
geno.vec <- c(1,0,0,NA,NA,0,NA,NA,0,0,NA,NA)
names(geno.vec) <- paste0("sub",1:12)
share.vec <- c()
occur.vec <- c()
i <- 1; 
while( sum(occur.vec) < n.occur & i <= n.bail ){
      founder <- sample(c(1,2,3,6,9,10),1,replace = FALSE)
      geno.vec[founder] <- 1
      geno.vec.sim <- GeneDrop(trio1, geno.vec)
      share.vec <- c(share.vec, geno.vec.sim["sub11"]==1 & geno.vec.sim["sub12"]==1)
      occur.vec <- c(occur.vec, geno.vec.sim["sub11"]==1 | geno.vec.sim["sub12"]==1)
      geno.vec[founder] <- 0
      i <- i + 1
}
i
sum(share.vec)
sum(occur.vec)
(p <- sum(share.vec)/sum(occur.vec))
1/p
@
=== Inbreeding ===
<<RVsharing.toy5, eval = TRUE, echo = FALSE>>=
id <- paste0("sub", 1:14)
fa.id <- c(NA,NA,NA,NA,NA,"sub1","sub1","sub1","sub3","sub4","sub5",NA,"sub10","sub12") 
ma.id <- c(NA,NA,NA,NA,NA,"sub2","sub2","sub2","sub6","sub7","sub8",NA,"sub9","sub11") 
test.ped <- pedigree(id = id, dadid = fa.id, momid = ma.id, sex = c(1,2,1,1,1,2,2,2,2,1,2,1,2,2))
fa.id <- ifelse(is.na(fa.id),"0",fa.id)
ma.id <- ifelse(is.na(ma.id),"0",ma.id)
@ 

<<plotped5, fig = TRUE, width = 3, eval = TRUE, echo = FALSE>>=
plot(test.ped)
@ 

<<inbred2, eval = TRUE, echo = TRUE, cache = FALSE>>=
trio1 <- new("Trio", id = "sub9", spouse = "sub10", offspring = list("sub13"))
trio2 <- new("Trio", id = "sub10", spouse = "sub9", offspring = list("sub13"))
trio3 <- new("Trio", id = "sub11", spouse = "sub12", offspring = list("sub14"))
trio4 <- new("Trio", id = "sub6", spouse = "sub3", offspring = list(trio1))
trio5 <- new("Trio", id = "sub7", spouse = "sub4", offspring = list(trio2))
trio6 <- new("Trio", id = "sub8", spouse = "sub5", offspring = list(trio3))
trio7 <- new("Trio", id = "sub1", spouse = "sub2", offspring = list(trio4,trio5,trio6))

geno.vec <- c(0,0,0,0,0,rep(NA,6),0,rep(NA,2))
names(geno.vec) <- paste0("sub",1:14)
occur.vec <- c()
share.vec <- c()
i <- 1;
while( sum(occur.vec) < n.occur & i <= n.bail ){
      founder <- sample(c(1:5,12),1,replace = FALSE)
      geno.vec[founder] <- 1
      geno.vec.sim <- GeneDrop(trio7, geno.vec)
      share.vec <- c(share.vec, geno.vec.sim["sub13"]==1 & geno.vec.sim["sub14"]==1)
      occur.vec <- c(occur.vec, geno.vec.sim["sub13"]==1 | geno.vec.sim["sub14"]==1)
      geno.vec[founder] <- 0
      i <- i + 1
}
i
sum(share.vec)
sum(occur.vec)
(p <- sum(share.vec)/sum(occur.vec))
1/p
@
== Complex Inbred Pedigrees  ==
<<pedlist, echo = TRUE, eval= TRUE, cache = FALSE>>=
data(ped.list)
@
<<ped, fig = TRUE, height = 20, width = 5, echo = TRUE, eval= TRUE, cache = FALSE>>=
layout(matrix(1:5, nrow = 5, ncol = 1))
plot.pedigree(ped.list[[47]], cex = 0.9)
plot.pedigree(ped.list[[48]], cex = 0.9)
plot.pedigree(ped.list[[52]], cex = 0.9)
plot.pedigree(ped.list[[55]], cex = 0.9)
plot.pedigree(ped.list[[56]], cex = 0.9)
@
