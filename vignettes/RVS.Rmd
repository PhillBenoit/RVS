---
title: "The RVS (Rare Variant Sharing) Package"
author: "Alexandre Bureau, Ingo Ruczinski, Samuel Younkin, Thomas Sherman"
data: "`r Sys.Date()`"
package: "`r pkg_ver('RVS')`"
bibliography: References.bib
vignette: >
    %\VignetteIndexEntry{The RVS Package}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
output:
    BiocStyle::html_document
---

```{r include=FALSE, cache=FALSE}
library(RVS)
library(kinship2)
library(snpStats)
```

# Setting up Pedigree Data

## Loading a Pedigree

For this example experiment we will consider four family types. A pair of first cousins, a pair of second cousins, a triple of first cousins, and a triple of second cousins. *RVS* comes with several example pedigrees and these four types can be found in the *samplePedigrees* list.

```{r}
data(samplePedigrees)

# store the pedigrees
fam_type_A <- samplePedigrees$firstCousinPair
fam_type_B <- samplePedigrees$secondCousinPair
fam_type_C <- samplePedigrees$firstCousinTriple
fam_type_D <- samplePedigrees$secondCousinTriple

# relabel the family ids for this example
fam_type_A$famid <- rep('SF_A', length(fam_type_A$id))
fam_type_B$famid <- rep('SF_B', length(fam_type_B$id))
fam_type_C$famid <- rep('SF_C', length(fam_type_C$id))
fam_type_D$famid <- rep('SF_D', length(fam_type_D$id))
```

## Plotting a Pedigree

In order to see the pedigree structure we can use the plot function provided by the *kinship2* package. In this family we have three second cousins that have been sequenced.

```{r}
plot(fam_type_D)
```

# Calculating Sharing Probabilities

## Sharing Probability for One Family, One Variant

The simplest use of the *RVS* package is to compute the probability that all sequenced subjects in a pedigree share a variant, given that it is seen it at least one of the subjects. For more information about this calculation see the documentation for the function *RVsharing*.

In this case we compute the probability for the family of three second cousins. Note that in the case of a single family and variant, the sharing probability can be interpreted as a p-value.

```{r}
prob <- RVsharing(fam_type_D)
```

## P-Value for Multiple Families, One Variant

In the case of a single variant seen across multiple families, we can compute the individual sharing probabilties with *RVsharing*, but the sharing probabilities can no longer be interpreted as a p-value in this case. The function *multipleFamilyPValue* can be used to compute the p-value.

```{r}
# compute the sharing probabilties for all families
fams <- list(fam_type_A, fam_type_B, fam_type_C, fam_type_D)
sharing_probs <- suppressMessages(RVsharing(fams))
sharing_probs

# compute p-value for this sharing pattern
sharing_pattern <- c(T, T, F, F)
names(sharing_pattern) <- names(sharing_probs)
multipleFamilyPValue(sharing_probs, sharing_pattern)
```

The *sharing_pattern* vector indicates whether or not the variant is observed in all sequenced subjects.

## P-Value for Multiple Families, Multiple Variants

The function *multipleVariantPValue* generalizes *multipleFamilyPValue*
across multiple variants. This function takes a *SnpMatrix* instead of a
specific sharing pattern. The behavior of this function could be acheived
by converting every column of a *SnpMatrix* into a sharing pattern across
families and applying *multipleFamilyPValue* across the columns.

The first step is reading in the data. See the *Data Input* vignette
for examples using different file types. Here we use a pedigree file
in the LINKAGE format.

```{r}
pedfile <- system.file("extdata/sample.ped.gz", package="RVS")
sample <- snpStats::read.pedfile(pedfile, snps=paste('variant', LETTERS[1:20], sep='_'))
sample
```

```{r echo=FALSE}
A_fams <- lapply(1:3, function(i) samplePedigrees$firstCousinPair)
B_fams <- lapply(1:3, function(i) samplePedigrees$secondCousinPair)
C_fams <- lapply(1:3, function(i) samplePedigrees$firstCousinTriple)
D_fams <- lapply(1:3, function(i) samplePedigrees$secondCousinTriple)
fams <- c(A_fams, B_fams, C_fams, D_fams)
famids <- unique(sample$fam$pedigree)
for (i in 1:12)
{
    fams[[i]]$famid <- rep(famids[i], length(fams[[i]]$id))
}
sharingProbs <- suppressMessages(RVsharing(fams))
```

In this data set we have 3 copies of each family type. The sharing 
probabilties for this set of families are:

```{r}
sharingProbs
```

We call the function as follows:

```{r}
multipleVariantPValue(sample$genotypes, sample$fam, sharingProbs)
```

Computation time may be slow with a large set of variants. 
*multipleVariantPValue* provides a filtering option based on the
potential p-values. Potential p-values are the lower bound on the 
p-value for each variant. In this example we omit any variants
whose potential p-values exceed the bonferroni cutoff.

```{r}
res <- multipleVariantPValue(sample$genotypes, sample$fam, sharingProbs, filter_type='bonferroni', alpha=0.05)
res
```

The effects of this filter can be seen here.

```{r}
pvals <- res$pvalues
ppvals <- res$potential_pvalues
ppvals_sub <- ppvals[names(pvals)]

plot(-log10(ppvals[order(ppvals)]), ylab="-log10 p-value", col="blue", type="l", xaxt="n", xlab="variants")
xlabel <- sapply(names(ppvals)[order(ppvals)], function(str) substr(str, nchar(str), nchar(str)))
axis(1, at=1:length(ppvals), labels=xlabel)
points(-log10(pvals[order(ppvals_sub)]), pch=20, cex=1.3)
bcut <- 0.05/(1:20)
lines(1:20,-log10(bcut),col="red",type="b",pch=20)
```

## Allele Frequency Sensitivity Analysis

## Cryptic Relatedness Analysis

## Enrichment Test

When calculating the enrichment p-value, note that a very small p-value may result in a very long computation time. Because of this, we can pass a minimum p-value threshold, where the greater of this threshold and the actual p-value will be returned.

Note that this calculation assumes the variants are independent.

```{r}
enrichmentPValue(sample$genotypes, sample$fam, sharingProbs, 0.001)
```

# References